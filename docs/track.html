<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>音频编码器性能对比</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2rem; overflow-x: auto; }
        table { border-collapse: collapse; margin: 1rem 0; min-width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: center; }
        th { background-color: #f8f9fa; cursor: pointer; position: sticky; top: 0; }
        th:hover { background-color: #e9ecef; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .sort-icon { margin-left: 5px; font-size: 0.8em; }
        .report-link { color: #0366d6; text-decoration: none; }
        .report-link:hover { text-decoration: underline; }
        #loading { margin: 20px 0; color: #6c757d; }
        .encoder-header { display: flex; flex-direction: column; }
        .weight-cell { background-color: #f0f7ff; }
    </style>
</head>
<body>
    <h1>基于Sheet2的性能数据展示</h1>
    <div id="loading">正在加载数据...</div>
    <div id="table-container"></div>

    <script>
        // 加载数据
        fetch('./Track1-MLP.json')
            .then(response => {
                if (!response.ok) throw new Error('网络响应异常');
                return response.json();
            })
            .then(data => {
                document.getElementById('loading').remove();
                renderTable(data);
            })
            .catch(error => {
                document.getElementById('loading').innerHTML = 
                    `<p style="color: red;">加载失败: ${error.message}</p>`;
            });

        // 渲染表格
        function renderTable(data) {
            const container = document.getElementById('table-container');
            const table = document.createElement('table');
            
            // 创建表头
            const thead = document.createElement('thead');
            
            // 第一行：数据集名称
            const headerRow1 = document.createElement('tr');
            headerRow1.appendChild(createCell('th', '编码器/数据集'));
            data.datasets.forEach(dataset => {
                headerRow1.appendChild(createCell('th', dataset));
            });
            thead.appendChild(headerRow1);
            
            // 第二行：任务权重
            const headerRow2 = document.createElement('tr');
            headerRow2.appendChild(createCell('th', '任务权重'));
            data.task_weights.forEach(weight => {
                const cell = createCell('td', weight);
                cell.classList.add('weight-cell');
                headerRow2.appendChild(cell);
            });
            thead.appendChild(headerRow2);
            
            // 第三行：baseline
            const baselineRow = document.createElement('tr');
            baselineRow.appendChild(createCell('th', 'baseline'));
            data.baseline.forEach(value => {
                baselineRow.appendChild(createCell('td', value));
            });
            
            // 编码器数据行
            const tbody = document.createElement('tbody');
            tbody.appendChild(baselineRow);
            
            data.encoders.forEach(encoder => {
                const row = document.createElement('tr');
                
                // 编码器名称+报告链接
                const nameCell = document.createElement('th');
                const nameWrapper = document.createElement('div');
                nameWrapper.className = 'encoder-header';
                
                nameWrapper.innerHTML = `
                    <span>${encoder.name}</span>
                    <a href="${encoder.report_link}" class="report-link" target="_blank">[报告]</a>
                `;
                
                nameCell.appendChild(nameWrapper);
                nameCell.onclick = (e) => {
                    if (e.target.tagName !== 'A') {
                        sortByEncoder(encoder.name, nameCell);
                    }
                };
                row.appendChild(nameCell);
                
                // 编码器数据
                encoder.data.forEach(value => {
                    row.appendChild(createCell('td', value));
                });
                
                tbody.appendChild(row);
            });
            
            table.appendChild(thead);
            table.appendChild(tbody);
            container.appendChild(table);
        }
        
        // 创建单元格辅助函数
        function createCell(type, content) {
            const cell = document.createElement(type);
            cell.textContent = content;
            return cell;
        }
        
        // 按编码器排序
        function sortByEncoder(encoderName, thElement) {
            const table = document.querySelector('table');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const sortIcons = document.querySelectorAll('.sort-icon');
            
            // 找出目标编码器在数据中的位置
            const encoderIndex = rows.findIndex(row => 
                row.cells[0].textContent.includes(encoderName));
            
            if (encoderIndex === -1) return;
            
            // 获取排序方向
            const isAsc = !thElement.getAttribute('data-sorted-asc');
            thElement.setAttribute('data-sorted-asc', isAsc);
            
            // 重置所有排序图标
            sortIcons.forEach(icon => icon.textContent = '↕');
            
            // 执行排序
            rows.sort((rowA, rowB) => {
                const aVal = parseFloat(rowA.cells[encoderIndex + 1].textContent);
                const bVal = parseFloat(rowB.cells[encoderIndex + 1].textContent);
                return isAsc ? bVal - aVal : aVal - bVal;
            });
            
            // 重新插入行
            rows.forEach(row => tbody.appendChild(row));
        }
    </script>
</body>
</html>
