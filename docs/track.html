<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Track1-MLP</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2rem; overflow-x: auto; }
        table { border-collapse: collapse; margin: 1rem 0; min-width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: center; }
        th { background-color: #f8f9fa; cursor: pointer; position: sticky; top: 0; }
        th:hover { background-color: #e9ecef; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .sort-icon { margin-left: 5px; font-size: 0.8em; }
        .report-link { color: #0366d6; text-decoration: none; }
        .report-link:hover { text-decoration: underline; }
        #loading { margin: 20px 0; color: #6c757d; }
        .encoder-header { display: flex; flex-direction: column; }
        .company-cell { background-color: #f0f7ff; }
        .avg-cell { background-color: #e7f5ff; font-weight: bold; }
        .highlight { background-color: #fff3cd; }
    </style>
</head>
<body>
    <h1>Track1-MLP</h1>
    <div id="loading">正在加载数据...</div>
    <div id="table-container"></div>

    <script>
        // 加载数据
        fetch('./Track1-MLP.json')
            .then(response => {
                if (!response.ok) throw new Error('网络响应异常');
                return response.json();
            })
            .then(data => {
                document.getElementById('loading').remove();
                renderTable(data);
            })
            .catch(error => {
                document.getElementById('loading').innerHTML = 
                    `<p style="color: red;">加载失败: ${error.message}</p>`;
            });

        // 渲染表格
        function renderTable(data) {
            const container = document.getElementById('table-container');
            const table = document.createElement('table');
            
            // 创建表头
            const thead = document.createElement('thead');
            
            // 第一行：主表头
            const headerRow1 = document.createElement('tr');
            headerRow1.appendChild(createHeaderCell("Team Company/Institute", "company-cell"));
            headerRow1.appendChild(createHeaderCell("Team Name"));
            headerRow1.appendChild(createHeaderCell("Team Name"));
            headerRow1.appendChild(createHeaderCell("Technical Report"));
            headerRow1.appendChild(createHeaderCell("Weighted Average Score", "avg-cell"));
            
            // 数据集列
            data.datasets.forEach(dataset => {
                headerRow1.appendChild(createHeaderCell(dataset));
            });
            
            thead.appendChild(headerRow1);
            table.appendChild(thead);
            
            // 创建数据行
            const tbody = document.createElement('tbody');
            
            data.encoders.forEach(encoder => {
                const row = document.createElement('tr');
                
                // 公司/机构
                row.appendChild(createCell('td', encoder.company, 'company-cell'));
                
                // 团队名称
                row.appendChild(createCell('td', encoder.team));
                
                // 编码器名称
                row.appendChild(createCell('td', encoder.name));
                
                // 报告链接
                const reportCell = createCell('td', '');
                if (encoder.report_link) {
                    reportCell.innerHTML = `
                        <a href="${encoder.report_link}" class="report-link" target="_blank">
                            查看报告
                        </a>
                    `;
                }
                row.appendChild(reportCell);
                
                // 加权平均（特殊样式）
                row.appendChild(createCell('td', encoder.weighted_avg, 'avg-cell'));
                
                // 各数据集得分
                encoder.scores.forEach(score => {
                    row.appendChild(createCell('td', score));
                });
                
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            container.appendChild(table);
            
            // 添加排序功能
            addSorting(table, data);
        }
        
        // 创建单元格辅助函数
        function createCell(type, content, className = '') {
            const cell = document.createElement(type);
            cell.textContent = content;
            if (className) cell.classList.add(className);
            return cell;
        }
        
        function createHeaderCell(content, className = '') {
            const th = document.createElement('th');
            th.innerHTML = content;
            if (className) th.classList.add(className);
            return th;
        }
        
        // 添加排序功能
        function addSorting(table, data) {
            const headers = table.querySelectorAll('thead th');
            
            headers.forEach((th, index) => {
                // 跳过前5列（公司、团队、编码器、报告、加权平均）
                if (index >= 5) {
                    th.innerHTML += ' <span class="sort-icon">↕</span>';
                    th.onclick = () => sortByDataset(index - 5, th);
                }
            });
        }
        
        // 按数据集排序
        function sortByDataset(datasetIndex, thElement) {
            const table = document.querySelector('table');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // 判断排序方向
            const isAsc = thElement.getAttribute('data-sort-dir') !== 'asc';
            thElement.setAttribute('data-sort-dir', isAsc ? 'asc' : 'desc');
            
            // 重置所有排序图标
            document.querySelectorAll('.sort-icon').forEach(icon => {
                icon.textContent = '↕';
            });
            
            // 更新当前列的排序图标
            thElement.querySelector('.sort-icon').textContent = isAsc ? '▲' : '▼';
            
            // 执行排序
            rows.sort((rowA, rowB) => {
                // +5是因为前5列是固定列
                const aVal = parseFloat(rowA.cells[datasetIndex + 5].textContent);
                const bVal = parseFloat(rowB.cells[datasetIndex + 5].textContent);
                return isAsc ? aVal - bVal : bVal - aVal;
            });
            
            // 重新插入行
            rows.forEach(row => tbody.appendChild(row));
        }
    </script>
</body>
</html>
